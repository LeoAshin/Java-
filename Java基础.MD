# Java基础
***

## 集合

### 1. HashMap底层实现
- HashMap是通过Entry对象数组与链表来实现对于KV数据的存储，同时在1.8中，引入了红黑树优化了对于hash碰撞国语严重下，扫描长链表的性能消耗问题。同时HashMap的初始capacity为16，如果插入长度=16*0.75的时候，会对整个数组进行一个*2的扩容，保证每次扩充长度都是2的幂次方。 因为2的幂次方下进行位运算最快。
- 同时，在1.7中，由于在同位链进行操作的时候，
### 2. ConcurrentHashMap
- HashMap的线程安全模式。 在1.7中采用Segament对于Entry块进行加锁处理，Segment是继承ReetrantLock。每次进行元素定位的时候都要进行两次hash来定位，第一次定位segment，第二定位数组位置，导致hash时间比其它的要长， 在1在1.8中采用了Node 继承Entry进行处理，大大减少了锁粒度，同时采用了Volatile与CAS来实现锁，Volatile是用来修饰Entry里的KV，

## 设计模式
### 1. 常用设计模式，及场景
- 常用设计模式例如单例，工厂，策略，代理模式，其中像策略模式的使用对于大量的业务if-else修缮有很大的用处，而像代理模式可以手写aop


### 2. 单例模式
- 常见的有恶汉模式与懒汉模式，其中懒汉模式基于一个懒加载，会对当前对象引用进行一次或者两次的费控判断，只有对象未生成的时候才会初始化对象，而恶汉模式则是直接生成了对象随用随取。

## 锁 与 多线程

### 1.Synchronized 与 ReentrantLock的区别。
- synchronized是jdk的关键字，利用
### 2.volatile 的作用
- volatile牵扯到一个问题，就是对于多个线程对于同一个数据进行操作时的数据可见性。以及避免指令重排问题. 但是对于volatile修饰的关键字对其操作，并不能保证其操作原子性，因为volatile虽然保证了其可见性，但是是基于修改之后，而不是对于修改之前。
- 对于加了volatile关键字的变量，在变异之后的文件中会有一个lock修饰符，对于lock修饰的变量，如果在高速缓存中出现了同一个对象，则会阻止其它线程的写操作，并且在当前线程修改完成后，立马同步到其它缓存
### 3.CAS
- Compare and Swap, 即对于一个变量进行操作时先对比内存地址上与预期值是否相等，如果相等，则更改它的值为B。这整个比较且更改的操作是原子性操作
### 4.Synchronized 升级与降级
- synchronized在锁升级分为四步
    + 无锁
    + 偏向锁
    + 轻量锁
    + 重量锁
- 默认情况下，在多线程竞争资源的时候，在竞争压力不大的情况下为了避免不必要的锁竞争的资源浪费，来对锁进行竞争，如果A线程获取了偏向锁，会在对象的markword中设置偏向锁偏移量，并且存入当前线程Id。如果在后续过程中再次遇到了同步块，如果当前线程ID=偏向锁中的线程ID或者之前的线程ID不存在，则不会重复加锁操作，节省加锁的cpu开销。偏向锁是不会主动释放锁的，只有当有其它现成尝试获取锁的时候或者是当前没有线程处于活动状态，才会使用CAS自旋释放锁操作讲对象设置为无锁或者轻量锁状态
- 当前线程持有偏向锁，并且正在执行通不过而又有其它的现成来获取该偏向锁时，锁升级到轻量锁。没有锁的线程通过CAS自旋来等待锁的释放并获取，使用短暂的忙等待来换取用户态到内核态的切换开销时间
- 当锁竞争过大，线程自旋次数超过10次，则会将轻量级锁升级到重量级锁。后续线程达到锁位置的时候，如果发现markword中是重量锁则会直接挂起，等待唤醒。
- hotspot中是支持锁的降级的，且降级阶段只发生在STW（stop-the-world）中，且只支持被VMThread访问的对象
### 5. Synchronized底层实现、
- synchronized关键字修饰的代码块下，class文件中会用monitorenter与monitorexit进行标记显示，对于每次获取到monitor对象的线程，会对monitorcount进行一个加一操作，也就是读取到monitorenter，读取到monitorexit时进行-1，当count=0 时，monitor被释放
- 而对于同步方法时采用的是隐式，不需要通过字节码标识来控制访问，而是通过访问方法区的方法表结构检查ACC_SYNCHRONIZED来确定方法是否被设置为同步。如果设置，执行线程将会首先拥有Monitor其它线程访问时无法获得同一个Monitor，如果这个方法发生异常，monitor对象也会被同时释放。

### 6. Synchronized与volatile的区别
- volatile与synchronized主要区别在于volatile对于对象的修饰时，对volatile操作并不是原子性操作，结合volatile的特性，volatile主要解决的是对于多线程操作同一个对象时，如果一个线程对其进行了修改操作，修改之后的结果对于其它线程应该是立即可见的。例如多核cpu下对于高速缓存的一致性问题。但是volatile的可见性是发生在修改之后，如果发生在修改前也有其它线程获取到了当前数据，则会出现一个多线程问题。

### 7.ThreadLocal实现
### 8.AQS模型
### 9.Java中的锁类型
- 公平锁与非公平锁
    + ReentrantLock就是基于AQS来实现公平锁与非公平锁，公平锁保证线程之间对于锁的竞争先到先得，保持一定的顺序。而非公平锁则是对于锁进行竞争，可能会出现后来先得的问题导致一个线程长时间阻塞
- 重入锁
    + 可重入锁也可以叫递归锁，同一个线程在玩层方法获取锁的时候，进入内层方法会自动获得锁，节省了获取锁导致的额外时间开销
- 分段锁
    + 分段锁是一种锁的数据，例如concurrenthashmap的设计，减少了锁粒度
- 自旋锁
    + 也是纸在synchronized下的轻量锁，会利用自旋去等待锁的释放，减少了线程上下文切换，但是对cpu会有额外开销
- 乐观锁与悲观锁
    + 两种锁顾名思义，
- 读写锁

### 10. 死锁的产生与定位
- 死锁的发生主要是由于竞争激烈而线程
### 11. ABA问题
- 主要问题是在于双方线程竞争资源的时候，A线程在读取预期内存中数据值得时候，另一个线程B对该地址进行了A-B-A的修改，导致了A无法准确认知到改地址的值进行了变更，不利于一些对过程敏感的操作，一般采用版本号来进行规避
## JVM 面试



### 1. JVM 模型

JVM主要分为元数据区,本地方法栈,堆,程序计数器,虚拟机方法栈. 

- 程序计数器和虚拟机方法栈属于线程共享,用与控制线程内的局部变量的地址存储以及对于方法的控制
- 元数据区属于对曾经JDK7的永久带方法区的替代,解决了可能因为永久代容量不够导致的内存泄漏问题. 元数据区默认的话是所有物理内存
- 本地方法栈是对于JVM原生方法的管理
- 堆所存放的是对于JVM中所有对象的管理.生成的对象都会存到堆中统一进行管理
  - 堆中划分为新生代和老年代,新生代中划分成eden,survivorfrom与survivorto,所有生成的对象在第一时间会被分配到eden中进行一个管理.

### 2. 常见GC算法

常见的GC算法有

### 3. 常见GC收集器
### 4. 双亲委派模式模型与优点
### 5. 类加载过程
### 6. JVM调优
### 7. 机器假死
### 8. JVM问题定位