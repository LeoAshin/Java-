# Java基础
***

## 集合

### 1. HashMap底层实现
- HashMap是通过Entry对象数组与链表来实现对于KV数据的存储，同时在1.8中，引入了红黑树优化了对于hash碰撞国语严重下，扫描长链表的性能消耗问题。同时HashMap的初始capacity为16，如果插入长度=16*0.75的时候，会对整个数组进行一个*2的扩容，保证每次扩充长度都是2的幂次方。 因为2的幂次方下进行位运算最快。
- 同时，在1.7中，由于在同位链进行操作的时候，
### 2. ConcurrentHashMap
- HashMap的线程安全模式。 在1.7中采用Segament对于Entry块进行加锁处理，Segment是继承ReetrantLock。每次进行元素定位的时候都要进行两次hash来定位，第一次定位segment，第二定位数组位置，导致hash时间比其它的要长， 在1在1.8中采用了Node 继承Entry进行处理，大大减少了锁粒度，同时采用了Volatile与CAS来实现锁，Volatile是用来修饰Entry里的KV，

## 设计模式
### 1. 常用设计模式，及场景
- 常用设计模式例如单例，工厂，策略，代理模式，其中像策略模式的使用对于大量的业务if-else修缮有很大的用处，而像代理模式可以手写aop


### 2. 单例模式
- 常见的有恶汉模式与懒汉模式，其中懒汉模式基于一个懒加载，会对当前对象引用进行一次或者两次的费控判断，只有对象未生成的时候才会初始化对象，而恶汉模式则是直接生成了对象随用随取。

## 锁 与 多线程

### 1.Synchronized 与 ReentrantLock的区别。
### 2.volatile 的作用
- volatile牵扯到一个问题，就是对于多个线程对于同一个数据进行操作时的数据可见性。以及避免指令重排问题. 但是对于volatile修饰的关键字对其操作，并不能保证其操作原子性，因为volatile虽然保证了其可见性，但是是基于修改之后，而不是对于修改之前。
- 对于加了volatile关键字的变量，在变异之后的文件中会有一个lock修饰符，对于lock修饰的变量，如果在高速缓存中出现了同一个对象，则会阻止其它线程的写操作，并且在当前线程修改完成后，立马同步到其它缓存
### 3.CAS
- Compare and Swap, 即对于一个变量进行操作时先对比内存地址上与预期值是否相等，如果相等，则更改它的值为B。这整个比较且更改的操作是原子性操作
### 4.Synchronized 升级与降级
### 5.ThreadLocal实现
### 6.AQS模型
### 7.Java中的锁类型
### 


## JVM 面试