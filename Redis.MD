# Redis 面试

***
### 1. Redis的单线程与多线程
- Redis整理来说首先，作为一个内存数据库，他使用了单线程直接对内存I/O进行操作，从而避免了在多线程情况下，上下文的切换时间甚至都快赶上内存的读写频率。并且，在对于redis-server与多个redis-cli的连接上，采用多路复用，增加redis对于数据的吞吐量
### 2. Redis缓存击穿，缓存雪崩，缓存穿透
- 缓存击穿，则对于某单点热点数据某个时间点热key失效，导致了大量请求直击数据库，可以采用多级缓存和本地缓存处理问题
- 缓存雪崩，对于大片的热点数据由于同时失效使得大量访问请求直接访问数据库，可以采用多级缓存或者对于数据进行一个随机时间失效处理，并且也可以将某热点数据设置永不失效，在数据库更新的时候进行一个更新
- 缓存穿透，则是对于没有存储在数据库中的数据，那么缓存也不会存在该数据，那么在大量这种数据访问的时候，则也会对数据库造成比较大的压力。那么这个时候可以使用布隆过滤器来解决这个问题。

### 2#. 布隆过滤器
 布隆过滤器类是一个bitmap，在足够小的存储空间下，将缓存中的所有key值都进行多次hash映射，将对应指针的bitmap上的值修改为1.那么当我在查询的时候，如果对应的hash值位上出了为1的值，那么当前访问的数据是可能存在于数据苦中的。多次hash是避免了在比较激烈的hash碰撞中，出现大量的哈希值相同的情况从而导致频繁的数据可能出现情况。同时这个时候就需要将表的长度扩大到一个合适的长度。太短，太容易被1塞满，太长影响效率。
 redis本身就适合作为布隆过滤器来使用
### 3. Redis pub/sub及底层实现原理
### 4. Redis数据落地实现
- Redis有两种数据持久化，一种是基于AOF，一种是基于RDB，其中AOF是基于对redis命令的设置，在恢复数据的时候进行差量恢复，速度比rdb块，rdb则是对于整体数据的存储，redis启动之类的情况的时候，效率要高与aof的
### 5. Redis集群模式
### 6. Redis数据模式
Redis中数据模式常用的有string，list，set，zset，map
不常用的还有geo，pub/sub
### 7. Redis应用
### 8. Redis分布式锁
- Redis分布式锁使用setnx来实现分布式锁，setnx原子性操作， setnx kv 如果k不存在则成功返回0，其它线程将无法获取。释放锁的时候进行delete操作，在这里面有几个问题需要解决
    + 如果在县城获取到锁进行操作之后，该线程被kill或者其它原因进行了无法恢复的原因，redis中的k无法正确得到释放，那么就回形成一个死锁，导致其它线程无法获取到锁，所以这个时候需要给锁设置一个expire时间
    + 设置了expire锁之后，也有可能因为redis因为某种原因重启，或者超时等原因，expire命令无法执行，从而导致死锁，这个时候可以使用lua脚本来进行解决，也可以单独生成一条守护线程来对expire的key进行一个记录和校对
    + 锁的误解除，比如说对于一些长时间执行的任务，例如线程需要10s来完成工作，而expire设置的超时时间是5s，在5s后锁超时，线程B获取到锁，这个时候线程A执行任务完成之后对锁释放实际上释放的是线程B的锁。这个时候需要在释放锁的时候对key进行一个校验是否是当前线程锁持有，针对这个可以模仿jdk中偏向锁一样，在key中对线程id进行一个记录。
    + 还有一点就和上述原因一样，在B获取到锁之后，实际上这个时候，A与B是属于并发执行，不再是处于线程安全阶段。这里可以使用守护线程在获取锁的时候判断锁是否被正确释放从而追加有效时间
    + 在redis集群当中，比如主备模式中，redis会将记录从buff中备份到备用节点当中，而如果当A线程获取到锁的时候，主节点宕机，切换到备用节点，此时最新的所数据并没有正确的同步到备用节点当中，从而导致B线程访问新的备用节点的时候会再次获取到锁，这种时候使用RedLock来进行锁定
### 9. RedLock机制
- RedLock用来解决，在主从设备下，由于主从复制的时间差有可能导致AB线程同时获取线程锁，导致线程不安全问题
RedLock利用了类似于Zookeeper的选举机制，每当机器从Redis获取锁的时候，需要在规定的时间内获取到规定数量的机器上，数量要超过N/2+1 也就是一半以上。用相同的k去获取锁，这个时间用linux毫秒计算，这个时间要尽可能的短，避免在同一台机器上超时。因为在成功获取到锁的时候，线程的实际持锁时间=锁过期时间-获取时间，也就是说实际上锁的释放时间也是如此。而如果锁获取失败，则客户端会一次到各个master节点上释放锁，包括没有成功获取的锁

### 10.redis中LRU与LFU
- LRU
    Redis中的内存淘汰机制中，基于LRU有6种
    + 拒绝
    + 从所有的Key中使用lru算法淘汰
    + 从所有设置了超时时间使用LRU算法淘汰
    + 从所有key中随机淘汰
    + 从所有设置了超时时间的key中超时淘汰
    + 从设置了过期时间的key中根据key的过期时间进行淘汰
- LFU
    4.0之后新的一个内存淘汰策略，即是优先淘汰非热点key数据。分为两种
    + 对设置了过期时间的key使用LFU淘汰错略
    + 对所有key使用LFU淘汰策略
    但是缺点就是由于要维护一个计数器列表对其进行排序操作对于内存和cpu的开销还是比较大的，但是一般情况下还是要优于LRU

### 11. RedisString底层实现